#!/usr/bin/env python3
# lidar_processor_node.py
# Subscribes to /scan (sensor_msgs/LaserScan) and publishes:
# - /lidar/front_min (std_msgs/Float32) = minimum distance in a frontal window
# Useful to avoid collisions and confirm approach distance.

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Float32
import math
import numpy as np

class LidarProcessor(Node):
    def __init__(self):
        super().__init__('lidar_processor_node')
        self.sub = self.create_subscription(LaserScan, '/scan', self.scan_cb, 10)
        self.pub = self.create_publisher(Float32, '/lidar/front_min', 10)

        self.declare_parameter('frontal_window_deg', 30)
        self.frontal_window_deg = self.get_parameter('frontal_window_deg').value

        self.get_logger().info(f'LidarProcessor started with frontal_window_deg={self.frontal_window_deg}')

    def scan_cb(self, msg: LaserScan):
        # LaserScan: angle_min, angle_increment, ranges[]
        angles = np.arange(len(msg.ranges)) * msg.angle_increment + msg.angle_min
        # convert to degrees
        angles_deg = np.degrees(angles)
        # select indices within frontal window (center 0 deg)
        mask = np.abs(angles_deg) <= self.frontal_window_deg
        if not np.any(mask):
            return
        # extract ranges and sanitize (remove NaNs and inf)
        ranges = np.array(msg.ranges)
        valid = np.isfinite(ranges) & (ranges > msg.range_min) & (ranges < msg.range_max)
        frontal_ranges = ranges[mask & valid]
        if frontal_ranges.size == 0:
            val = float('inf')
        else:
            val = float(np.nanmin(frontal_ranges))
        self.pub.publish(Float32(data=val))

def main(args=None):
    rclpy.init(args=args)
    node = LidarProcessor()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()



